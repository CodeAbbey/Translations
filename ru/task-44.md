После решения задачи [Dice Rolling](./dice-rolling), мы знаем как преобразовать дробное значение от `0.0` до `1.0`
в целое, принадлежащее заданному диапазону - например к значениям между `1` и `6`, чтобы сымитировать бросок игрального кубика.

Однако многие языки программирования (в том числе **C/C++**, **PHP**, **Pascal**) имеют генератор случайных чисел,
который наоборот возвращает целое число в диапазоне от `0` до некоторого (обычно большого) максимума.
Как преобразовать такие числа в значения очков на грани кубика?

Оказывается, такой случай даже проще. Применим следующий подход:

1. Разделим случайное значение `R` на `N` (количество разных значений которые мы хотим получать - т.е. `6` для кубика)
    и возьмем остаток. Он будет в диапазоне от `0` до `N - 1`.
2. Теперь сдвинем этот диапазон к требуемому, просто добавив `1` (т.е. нижнюю границу нужного нам диапазона) - и получим
    значение от `1` to `N`.

Этот метод не очень точен если `N` недостаточно мало в сравнении с `max` генератора (наибольшим возможным случайным числом).
Однако в большинстве типовых случаев (бросание монетки, кубика, раздача игральных карт) он вполне подходит.

Для практики попробуем следующее упражнение:

**Входные данные** содержат количество тест-кейсов (бросков пары игральных костей) в первой строке.  
Остальные строки содержат сами тест-кейсы - в каждом по два случайных целых числа (между `0` и примерно `2,000,000,000`) -
превратим их в очки выброшенные на двух виртуальных кубиках и сложим.  
**Ответ** должен содержать сумму броска пары кубиков для каждого случая, через пробел.

Пример:

	входные данные:
	7
	193170145 1912748246
	753156389 614113621
	1824520917 53700559
	1288077384 911939603
	1939066598 1695763253
	1905581606 1811712139
	878644967 1090885451
	
	
	ответ:
	5 8 6 7 9 5 12
