对于任意类型的纸牌游戏洗牌都是比较重要的。由于只有少数编程语言自带随机混洗数组的内置函数（比如PHP），所以有必要学习一些有用的算法。

我们以下面的符号来代替卡牌：

    ranks: A, 2, 3, 4, 5, 6, 7, 8, 9, T, J, Q, K
    suits: C, D, H, S

这里面 `CQ` 代表 "梅花Q(Queen of Clubs)"，`HT` 代表 "红桃10(Ten of Hearts)"，`D2` 代表 "方片2(Two of Diamonds)"，`SA` 代表 "黑桃A(Ace of Spades)"。

一共有52张牌，所有在洗牌前应该将它们放入包含52个元素的数组中。数组的初始排序如下：13张梅花，然后是13张方片，然后是13张红桃，最后是13张黑桃。在每种花色中卡牌从 Ace 到 King 排列，因此整个排序就像这样：

    [ CA, C2, C3, ..., CQ, CK, DA, D2, ..., DK, HA, H2, ..., HK, SA, S2, ..., SK ]

然后你需要针对每张牌生成一个处于 `0 ... 51` 内的随机数，然后将这张牌与另一张牌互换位置，要互换的位置就是你随机生成数字所对应的卡牌的位置（数组从0开始计数）。类似下面这样：

    FOR i = 0 ... 51 :
        LET j = RANDOM(0 ... 51)
        SWAP deck[i] WITH deck[j]

例如，我们拿第一张牌 `CA` 然后为它生成一个随机数 `15` - 这意味着第一张牌需要移动到 `D3` 所在的15这个位置 - 然后 `D3` 应该移动到第一张牌所在的位置 `0`。然后我们拿位置 `1` 上的 `C2` 这张牌，为它生成一个随机数字 `50` - 因此 `C2` 就与位置 50 上的 `SQ` 进行交换。以此类推。

你将会拿到一串非负随机整数 - 如果这些数字比想要的位置索引值大就把它们 `与52取模` 来进行修建，就像在 [`Double Dice Roll`][1] 任务中那样。执行洗牌操作然后将新的牌序作为结果打印出来。

**输入数据** 将会包含52个非负整数，你将使用这些整数来进行洗牌操作。

**答案** 应当包含洗牌后的卡牌，使用分好将每个卡牌隔开。

举个栗子：

    input data:
    5814 1316 2080 2712 0 647 8098 315 44 6354 7867 100 61 763 6731 685 42 9309 569 92 701 562
            85 8311 698 220 929 71 684 518 113 61 19 168 745 16 655 9548 6018 2686 25 785 81 721
            964 85 44 614 4 509 8708 19

    answer:
    C5 D5 S4 C8 CQ S3 HK C9 H3 H6 D3 ST DT HT C6 CK DA H9 SJ SK DK C2 DQ S5 H4 D7 S7 S2 C4 D9 CT
            HJ HQ D2 SA CA H5 H2 C7 D4 CJ D6 S9 HA S8 D8 S6 SQ C3 DJ H8 H7

[1]: https://www.codeabbey.com/index/task_view/double-dice-roll